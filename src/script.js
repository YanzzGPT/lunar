document.addEventListener('DOMContentLoaded', () => {
    // --- Elements ---
    const authContainer = document.getElementById('authContainer');
    const appContainer = document.getElementById('appContainer');
    const loginBox = document.getElementById('loginBox');
    const signUpBox = document.getElementById('signUpBox');
    const showSignUp = document.getElementById('showSignUp');
    const showLogin = document.getElementById('showLogin');
    const loginForm = document.getElementById('loginForm');
    const signUpForm = document.getElementById('signUpForm');
    const sidebar = document.getElementById('sidebar');
    const menuToggle = document.getElementById('menuToggle');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const chatContent = document.getElementById('chatContent');
    const chatMessages = document.getElementById('chatMessages');
    const welcomeScreen = document.getElementById('welcomeScreen');
    const newChatBtn = document.getElementById('newChatBtn');
    const conversationsList = document.getElementById('conversationsList');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const userNameSetting = document.getElementById('userNameSetting');
    const modelSetting = document.getElementById('modelSetting');
    const themeToggle = document.getElementById('themeToggle');
    const userNameDisplay = document.getElementById('userNameDisplay');
    const voiceInputBtn = document.getElementById('voiceInputBtn');
    const attachFileBtn = document.getElementById('attachFileBtn');
    const fileInput = document.getElementById('fileInput');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const welcomeUserTitle = document.getElementById('welcomeUserTitle');
    const chatModeRadios = document.querySelectorAll('input[name="chatMode"]');
    const imagePreviewContainer = document.getElementById('imagePreviewContainer');

    // --- State & System Instruction ---
    let currentUser = null;
    let conversations = {};
    let currentChatId = null;
    let currentChatMode = 'standard';
    let currentSystemInstruction = null;
    let stagedImageDataUrls = [];

    let apiKeys = [
        "AIzaSyAP7YOamUiSwxtBxIjfIhVDf2Jyzfaj1Z0",
        "AIzaSyDGpvf2IY5n4tcitnWUyBFePjvCQQMAnNs", "AIzaSyDH0gUYY0YxVzXPn3rPFPARlhSORzq7zyM",
        "AIzaSyDoX3XatC5x-YN5TtyHBF5P3LEKLm4L3SU", "AIzaSyCJjTwVm-3x42R5lkcRErMxtEmG3_DcejA",
        "AIzaSyAiJR0SdzY7wpvYIr4ZGdPAkIYqHKrmq70", "AIzaSyDBQ_aET7uzAkz28hYos8K99B8bX3OlbkE",
        "AIzaSyCAgajm99EejnJiUlVC0y-RhYnXK3cxrjg", "AIzaSyA9hf7FrWlsO9tbueuj_aK-trcqwucyon8",
        "AIzaSyCDgQENhaOiLrtkhZVe0ToG4qK0QFAyjh0"
    ];
    let currentApiKeyIndex = 0;

    const SYSTEM_INSTRUCTION_TEMPLATE = "Kamu adalah Lunar A.I, asisten yang membantu dan ramah. Kamu diciptakan oleh Syawaliuz Octavian (Liuzz) & Satria Arkanata (Ark). Kamu berpengetahuan luas, kreatif, dan selalu sopan. Kamu sedang berbicara dengan pengguna bernama {userName}. Ingat nama ini dan gunakan untuk membuat percapan terasa personal jika relevan. Jangan sebut dirimu gemini atau lainnya, anggap dirimu tidak berhubungan dengan google dan sejenisnya.";
    const getSystemInstruction = (userName) => ({ parts: [{ text: SYSTEM_INSTRUCTION_TEMPLATE.replace('{userName}', userName) }] });
    
    // --- Sidebar, Auth, Chat Management ---
    const checkLoginStatus = () => { const loggedInUser = localStorage.getItem('lunar_currentUser'); if (loggedInUser) { currentUser = JSON.parse(loggedInUser); const firstName = currentUser.name.split(' ')[0]; welcomeUserTitle.textContent = `Good day, ${firstName}!`; currentSystemInstruction = getSystemInstruction(firstName); showApp(); loadSettings(); loadConversations(); } else { showAuth(); } };
    let isSidebarOpen = false, isSidebarAnimating = false; const animationDuration = 300; const openSidebar = () => { if (isSidebarOpen || isSidebarAnimating) return; isSidebarAnimating = true; document.body.classList.add('sidebar-is-open'); isSidebarOpen = true; setTimeout(() => { isSidebarAnimating = false; }, animationDuration); }; const closeSidebar = () => { if (!isSidebarOpen || isSidebarAnimating) return; isSidebarAnimating = true; document.body.classList.remove('sidebar-is-open'); isSidebarOpen = false; setTimeout(() => { isSidebarAnimating = false; }, animationDuration); }; const toggleSidebar = () => { isSidebarOpen ? closeSidebar() : openSidebar(); }; const showApp = () => { document.body.classList.remove('state-auth'); document.body.classList.add('state-app'); }; const showAuth = () => { document.body.classList.remove('state-app'); document.body.classList.add('state-auth'); }; showSignUp.addEventListener('click', (e) => { e.preventDefault(); loginBox.style.display = 'none'; signUpBox.style.display = 'block'; }); showLogin.addEventListener('click', (e) => { e.preventDefault(); signUpBox.style.display = 'none'; loginBox.style.display = 'block'; }); signUpForm.addEventListener('submit', (e) => { e.preventDefault(); const name = document.getElementById('signUpName').value, email = document.getElementById('signUpEmail').value, password = document.getElementById('signUpPassword').value; const users = JSON.parse(localStorage.getItem('lunar_users') || '{}'); if (users[email]) { alert('User already exists!'); return; } users[email] = { name, password }; localStorage.setItem('lunar_users', JSON.stringify(users)); currentUser = { name, email }; localStorage.setItem('lunar_currentUser', JSON.stringify(currentUser)); checkLoginStatus(); }); loginForm.addEventListener('submit', (e) => { e.preventDefault(); const email = document.getElementById('loginEmail').value, password = document.getElementById('loginPassword').value; const users = JSON.parse(localStorage.getItem('lunar_users') || '{}'); const user = users[email]; if (user && user.password === password) { currentUser = { name: user.name, email }; localStorage.setItem('lunar_currentUser', JSON.stringify(currentUser)); checkLoginStatus(); } else { alert('Invalid email or password.'); } }); const setActiveConversation = (id) => { document.querySelectorAll('.conversation-item').forEach(item => item.classList.remove('active')); if (id) { const activeItem = document.querySelector(`.conversation-item[data-id='${id}']`); if (activeItem) activeItem.classList.add('active'); } }; newChatBtn.addEventListener('click', () => { currentChatId = null; chatMessages.innerHTML = ''; welcomeScreen.style.display = 'flex'; messageInput.disabled = false; sendButton.disabled = false; setActiveConversation(null); closeSidebar(); clearImagePreview(); }); clearAllBtn.addEventListener('click', () => { if (confirm('Are you sure you want to clear all conversations? This action cannot be undone.')) { conversations = {}; saveConversations(); renderConversationsList(); newChatBtn.click(); } });
    const loadChat = (id) => { currentChatId = id; chatMessages.innerHTML = ''; welcomeScreen.style.display = 'none'; const conversation = conversations[id]; conversation.forEach(msg => createMessageFromHistory(msg)); setActiveConversation(id); closeSidebar(); };
    
    // --- Message UI & Animations ---
    const formatDuration = (seconds) => { if (seconds < 60) return `${seconds.toFixed(1)}s`; const minutes = Math.floor(seconds / 60); const remainingSeconds = Math.round(seconds % 60); return `${minutes}m ${remainingSeconds}s`; }; const addCopyToClipboard = (element, text) => { if (!navigator.clipboard || !text) return; const copyBtn = document.createElement('button'); copyBtn.className = 'copy-btn'; copyBtn.textContent = 'Copy'; copyBtn.onclick = () => navigator.clipboard.writeText(text).then(() => { copyBtn.textContent = 'Copied!'; setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500); }); element.appendChild(copyBtn); };
    const formatMessageContent = (container, text) => { if (typeof text !== 'string' || !text) { return; } const codeBlockRegex = /```(\w+)?\n?([\s\S]*?)```/g; let lastIndex = 0; let match; const processText = (txt) => txt.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\*\*(.*?)\*\*/g, '<b>$1</b>').replace(/\*(.*?)\*/g, '<i>$1</i>').replace(/\n/g, '<br>'); while ((match = codeBlockRegex.exec(text)) !== null) { if (match.index > lastIndex) { const p = document.createElement('p'); p.innerHTML = processText(text.substring(lastIndex, match.index)); container.appendChild(p); } const codeContent = match[2].trim(); const codeBlockDiv = document.createElement('div'); codeBlockDiv.className = 'code-block'; const pre = document.createElement('pre'); const code = document.createElement('code'); if (match[1]) { code.className = `language-${match[1]}`; } code.textContent = codeContent; pre.appendChild(code); codeBlockDiv.appendChild(pre); addCopyToClipboard(codeBlockDiv, codeContent); container.appendChild(codeBlockDiv); hljs.highlightElement(code); } if (lastIndex < text.length) { const p = document.createElement('p'); p.innerHTML = processText(text.substring(lastIndex)); container.appendChild(p); } };
    const createMessageFromHistory = (msg) => { const textPart = msg.parts.find(p => p.text); const imageParts = msg.parts.filter(p => p.image_url || p.inline_data); let messageElement; if (msg.role === 'user') { const imageUrls = imageParts.map(p => `data:${p.inline_data.mime_type};base64,${p.inline_data.data}`); messageElement = createUserMessageElement(textPart?.text, imageUrls); } else { const imagePart = imageParts[0]; messageElement = createModelMessageElement(textPart, imagePart); } chatMessages.appendChild(messageElement); chatContent.scrollTop = chatContent.scrollHeight; return messageElement; };
    const createUserMessageElement = (text, imageUrls = []) => { const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'user'); const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; if (imageUrls.length > 0) { const imageContainer = document.createElement('div'); imageContainer.style.display = 'flex'; imageContainer.style.gap = '8px'; imageContainer.style.flexWrap = 'wrap'; imageUrls.forEach(url => { const img = document.createElement('img'); img.src = url; img.style.maxWidth = '100px'; img.style.maxHeight = '100px'; img.style.borderRadius = '8px'; img.style.objectFit = 'cover'; imageContainer.appendChild(img); }); messageWrapper.appendChild(imageContainer); if (text) imageContainer.style.marginBottom = '10px'; } if (text) { const messageContentDiv = document.createElement('div'); messageContentDiv.className = 'message-content'; formatMessageContent(messageContentDiv, text); messageWrapper.appendChild(messageContentDiv); } messageDiv.appendChild(messageWrapper); return messageDiv; };
    const createModelMessageElement = (textPart, imagePart) => { const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'ai'); const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; messageDiv.appendChild(messageWrapper); if (textPart) { const messageContentDiv = document.createElement('div'); messageContentDiv.className = 'message-content'; formatMessageContent(messageContentDiv, textPart.text); messageWrapper.appendChild(messageContentDiv); addCopyToClipboard(messageDiv, textPart.text); } if (imagePart) { const imageContainer = document.createElement('div'); imageContainer.className = 'image-container'; if (textPart) imageContainer.style.marginTop = '1rem'; displayGeneratedImage(imageContainer, imagePart.image_url); messageWrapper.appendChild(imageContainer); } return messageDiv; };
    const createDynamicThinkingMessageElement = (mode, startTime) => { const thinkingPhrases = { thinking: ["Menganalisis permintaan...", "Mempertimbangkan berbagai sudut pandang...", "Menyusun kerangka jawaban...", "Merumuskan respons..."], search: ["Memahami kueri...", "Menggunakan Google Search...", "Menganalisis hasil pencarian...", "Merangkum informasi...", "Menyusun jawaban akhir..."], image: ["Memahami prompt Anda...", "Menyiapkan kanvas digital...", "Mengumpulkan inspirasi...", "Melukis mahakarya Anda..."] }; const phrases = thinkingPhrases[mode] || thinkingPhrases.thinking; let phraseIndex = 0; const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'ai'); const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; const messageContentDiv = document.createElement('div'); messageContentDiv.className = 'message-content'; messageContentDiv.innerHTML = `<div class="typing-indicator"><span></span><span></span><span></span></div> <span id="thinking-text">${phrases[0]}</span> <span class="time-indicator live">0.0s</span>`; messageWrapper.appendChild(messageContentDiv); messageDiv.appendChild(messageWrapper); chatMessages.appendChild(messageDiv); chatContent.scrollTop = chatContent.scrollHeight; const thinkingTextSpan = messageDiv.querySelector('#thinking-text'); const timerSpan = messageDiv.querySelector('.time-indicator.live'); const phraseIntervalId = setInterval(() => { phraseIndex = (phraseIndex + 1) % phrases.length; thinkingTextSpan.textContent = phrases[phraseIndex]; }, 2500); const timerIntervalId = setInterval(() => { const elapsed = (performance.now() - startTime) / 1000; timerSpan.textContent = `${elapsed.toFixed(1)}s`; }, 100); return { element: messageDiv, stop: () => { clearInterval(phraseIntervalId); clearInterval(timerIntervalId); } }; };
    
    async function typeResponse(container, text) {
        const processText = (txt) => txt.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\*\*(.*?)\*\*/g, '<b>$1</b>').replace(/\*(.*?)\*/g, '<i>$1</i>').replace(/\n/g, '<br>');

        const typeSegment = (element, segment) => {
            return new Promise(resolve => {
                let i = 0;
                const typingInterval = setInterval(() => {
                    if (i < segment.length) {
                        element.textContent += segment.charAt(i);
                        i++;
                        chatContent.scrollTop = chatContent.scrollHeight;
                    } else {
                        clearInterval(typingInterval);
                        resolve();
                    }
                }, 10); // Typing speed
            });
        };

        const codeBlockRegex = /```(\w*)\n?([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;

        while ((match = codeBlockRegex.exec(text)) !== null) {
            if (match.index > lastIndex) {
                const textSegment = text.substring(lastIndex, match.index);
                const p = document.createElement('p');
                container.appendChild(p);
                await typeSegment(p, textSegment);
                p.innerHTML = processText(textSegment);
            }
            
            const language = match[1] || 'plaintext';
            const codeContent = match[2].trim();

            const codeBlockDiv = document.createElement('div');
            codeBlockDiv.className = 'code-block';
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            code.className = `language-${language}`;
            
            pre.appendChild(code);
            codeBlockDiv.appendChild(pre);
            container.appendChild(codeBlockDiv);
            
            await typeSegment(code, codeContent);
            
            hljs.highlightElement(code);
            addCopyToClipboard(codeBlockDiv, codeContent);

            lastIndex = codeBlockRegex.lastIndex;
        }

        if (lastIndex < text.length) {
            const remainingText = text.substring(lastIndex);
            const p = document.createElement('p');
            container.appendChild(p);
            await typeSegment(p, remainingText);
            p.innerHTML = processText(remainingText);
        }
    }

    const saveConversations = () => { try { localStorage.setItem(`lunar_conversations_${currentUser.email}`, JSON.stringify(conversations)); } catch (e) { console.error("Failed to save conversations:", e); alert("Gagal menyimpan percakapan. Kemungkinan memori penuh."); } };
    const loadConversations = () => { conversations = JSON.parse(localStorage.getItem(`lunar_conversations_${currentUser.email}`) || '{}'); renderConversationsList(); };
    const renderConversationsList = () => { conversationsList.innerHTML = ''; Object.keys(conversations).forEach(id => { const conversation = conversations[id]; const firstUserMessage = conversation.find(msg => msg.role === 'user'); if (firstUserMessage) { const item = document.createElement('div'); item.classList.add('conversation-item'); const firstTextPart = firstUserMessage.parts.find(p => p.text); item.textContent = (firstTextPart?.text || "Image Prompt").substring(0, 30) + '...'; item.dataset.id = id; item.onclick = () => loadChat(id); conversationsList.prepend(item); } }); setActiveConversation(currentChatId); };
    const extractBase64Data = (dataUrl) => { const parts = dataUrl.split(','); const mimeType = parts[0].match(/:(.*?);/)[1]; const data = parts[1]; return { mimeType, data }; };

    // --- MAIN SEND MESSAGE FLOW ---
    const sendMessage = async () => { const messageText = messageInput.value.trim(); if (!messageText && stagedImageDataUrls.length === 0) return; welcomeScreen.style.display = 'none'; let isNewChat = !currentChatId; if (isNewChat) { currentChatId = Date.now().toString(); conversations[currentChatId] = []; } const userMessageParts = []; if (messageText) userMessageParts.push({ text: messageText }); stagedImageDataUrls.forEach(dataUrl => { const { mimeType, data } = extractBase64Data(dataUrl); userMessageParts.push({ inline_data: { mime_type: mimeType, data: data } }); }); const userMsgData = { role: 'user', parts: userMessageParts }; conversations[currentChatId].push(userMsgData); createMessageFromHistory(userMsgData); if (isNewChat) renderConversationsList(); messageInput.value = ''; clearImagePreview(); messageInput.disabled = true; sendButton.disabled = true; try { if (currentChatMode === 'image') await handleImageMode(); else if (currentChatMode === 'search') await handleSearchMode(); else await handleStandardChat(); } catch (error) { console.error("Error during message handling:", error); createMessageFromHistory({ role: 'model', parts: [{ text: `Maaf, terjadi kesalahan tak terduga: ${error.message}` }] }); } finally { messageInput.disabled = false; sendButton.disabled = false; messageInput.focus(); saveConversations(); } };
    
    const addTimestamp = (element, startTime) => { if (element) { try { const duration = (performance.now() - startTime) / 1000; const timeIndicator = document.createElement('div'); timeIndicator.className = 'time-indicator'; timeIndicator.textContent = `Dihasilkan dalam ${formatDuration(duration)}`; element.querySelector('.message-wrapper').appendChild(timeIndicator); } catch (e) { console.error("Failed to add timestamp:", e); } } };

    // --- Chat Mode Handlers ---
    const handleStandardChat = async () => { const startTime = performance.now(); const thinkingAnimation = createDynamicThinkingMessageElement('thinking', startTime); let finalMessageElement; try { const result = await callGoogleAI(conversations[currentChatId], null, currentSystemInstruction); conversations[currentChatId].push({ role: 'model', parts: [{ text: result.responseText }] }); thinkingAnimation.stop(); thinkingAnimation.element.remove(); const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'ai'); const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; const messageContentDiv = document.createElement('div'); messageContentDiv.className = 'message-content'; messageWrapper.appendChild(messageContentDiv); messageDiv.appendChild(messageWrapper); chatMessages.appendChild(messageDiv); finalMessageElement = messageDiv; await typeResponse(messageContentDiv, result.responseText); addCopyToClipboard(messageDiv, result.responseText); addTimestamp(finalMessageElement, startTime); } catch (error) { thinkingAnimation.stop(); thinkingAnimation.element.remove(); const errorParts = [{ text: error.message }]; conversations[currentChatId].push({ role: 'model', parts: errorParts }); finalMessageElement = createMessageFromHistory({ role: 'model', parts: errorParts }); addTimestamp(finalMessageElement, startTime); } };
    const handleSearchMode = async () => { const startTime = performance.now(); const thinkingAnimation = createDynamicThinkingMessageElement('search', startTime); let finalMessageElement; try { const searchTool = [{ "google_search": {} }]; const result = await callGoogleAI(conversations[currentChatId], searchTool, currentSystemInstruction); conversations[currentChatId].push({ role: 'model', parts: [{ text: result.responseText }] }); thinkingAnimation.stop(); thinkingAnimation.element.remove(); const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'ai'); const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; const messageContentDiv = document.createElement('div'); messageContentDiv.className = 'message-content'; messageWrapper.appendChild(messageContentDiv); messageDiv.appendChild(messageWrapper); chatMessages.appendChild(messageDiv); finalMessageElement = messageDiv; await typeResponse(messageContentDiv, result.responseText); addCopyToClipboard(messageDiv, result.responseText); addTimestamp(finalMessageElement, startTime); } catch (error) { thinkingAnimation.stop(); thinkingAnimation.element.remove(); const errorParts = [{ text: error.message }]; conversations[currentChatId].push({ role: 'model', parts: errorParts }); finalMessageElement = createMessageFromHistory({ role: 'model', parts: errorParts }); addTimestamp(finalMessageElement, startTime); } };
    const handleImageMode = async () => { const startTime = performance.now(); const thinkingAnimation = createDynamicThinkingMessageElement('image', startTime); let finalMessageElement; try { const result = await generateImageWithGemini(conversations[currentChatId]); if (!result.textResponse && !result.imageUrl) throw new Error("API tidak menghasilkan teks ataupun gambar."); const modelParts = []; if (result.textResponse) modelParts.push({ text: result.textResponse }); if (result.imageUrl) modelParts.push({ image_url: result.imageUrl }); conversations[currentChatId].push({ role: 'model', parts: modelParts }); thinkingAnimation.stop(); thinkingAnimation.element.remove(); const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'ai'); const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; messageDiv.appendChild(messageWrapper); chatMessages.appendChild(messageDiv); finalMessageElement = messageDiv; if (result.textResponse) { const messageContentDiv = document.createElement('div'); messageContentDiv.className = 'message-content'; messageWrapper.appendChild(messageContentDiv); await typeResponse(messageContentDiv, result.textResponse); addCopyToClipboard(messageDiv, result.textResponse); } if (result.imageUrl) { const imageContainer = document.createElement('div'); imageContainer.className = 'image-container'; if (result.textResponse) imageContainer.style.marginTop = '1rem'; displayGeneratedImage(imageContainer, result.imageUrl); messageWrapper.appendChild(imageContainer); } addTimestamp(finalMessageElement, startTime); } catch (error) { thinkingAnimation.stop(); thinkingAnimation.element.remove(); const errorParts = [{ text: error.message }]; conversations[currentChatId].push({ role: 'model', parts: errorParts }); finalMessageElement = createMessageFromHistory({ role: 'model', parts: errorParts }); addTimestamp(finalMessageElement, startTime); } };

    // --- API Calls & Helpers ---
    const callGoogleAI = async (history, tools = null, systemInstruction = null, retries = 0) => { if (retries >= apiKeys.length) throw new Error("Semua kunci API gagal. Kemungkinan model overload atau kunci tidak valid."); const apiKey = apiKeys[currentApiKeyIndex]; const model = localStorage.getItem('lunar_model') || 'gemini-2.5-flash'; const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`; const cleanHistory = history.map(msg => ({ role: msg.role === 'user' ? 'user' : 'model', parts: msg.parts.filter(part => part.text || part.inline_data) })).filter(msg => msg.parts.length > 0); const requestBody = { "contents": cleanHistory }; if (systemInstruction) { requestBody.system_instruction = systemInstruction; } if (tools) { requestBody.tools = tools; } try { const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) }); const responseData = await response.json(); if (!response.ok) { if (responseData.error && [400, 403, 429].includes(response.status)) { currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length; return callGoogleAI(history, tools, systemInstruction, retries + 1); } throw new Error(responseData.error?.message || `HTTP error! Status: ${response.status}`); } const candidate = responseData.candidates?.[0]; if (!candidate) { throw new Error("Respons dari AI tidak valid (tidak ada kandidat)."); } if (candidate.finishReason && candidate.finishReason !== "STOP") { throw new Error(`Maaf, respons saya diblokir oleh filter keamanan (Alasan: ${candidate.finishReason}). Coba prompt lain.`); } if (!candidate.content || !candidate.content.parts) { throw new Error("Respons dari AI tidak valid (tidak ada konten)."); } const responseText = candidate.content.parts.map(part => part.text).filter(Boolean).join(""); if (!responseText) { if (candidate.content.parts.some(part => part.toolCall)) { return { responseText: "Menggunakan alat..." }; } throw new Error("Respons dari AI tidak berisi konten teks yang valid."); } return { responseText }; } catch (error) { console.error("Google AI Call Error:", error); if (retries < apiKeys.length - 1) { currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length; return callGoogleAI(history, tools, systemInstruction, retries + 1); } throw error; } };
    const generateImageWithGemini = async (history, retries = 0) => { if (retries >= apiKeys.length) throw new Error("Semua kunci API gagal."); const apiKey = apiKeys[currentApiKeyIndex]; const modelId = "gemini-2.0-flash-preview-image-generation"; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`; const lastUserMessage = history.filter(m => m.role === 'user').pop(); if (!lastUserMessage) throw new Error("Tidak ada prompt pengguna untuk generasi gambar."); const userTextPart = lastUserMessage.parts.find(p => p.text); const userImageParts = lastUserMessage.parts.filter(p => p.inline_data); if (!userTextPart && userImageParts.length === 0) { throw new Error("Prompt harus berisi teks atau gambar."); } const finalParts = []; const stylePrefix = "ini adalah system instruction: namamu adalah Lunar A.I+ dan ini adalah prompt dari user: "; const userText = userTextPart ? userTextPart.text : ''; finalParts.push({ "text": stylePrefix + userText }); userImageParts.forEach(imgPart => finalParts.push(imgPart)); const requestBody = { "contents": [{ "role": "user", "parts": finalParts }], "generationConfig": { "responseModalities": ["IMAGE", "TEXT"] } }; try { const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) }); const responseData = await response.json(); if (!response.ok) { if (responseData.error && [400, 403, 429].includes(response.status)) { currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length; return generateImageWithGemini(history, retries + 1); } throw new Error(responseData.error?.message || `HTTP error! Status: ${response.status}`); } const candidate = responseData.candidates?.[0]; if (candidate && candidate.finishReason && candidate.finishReason !== "STOP") { throw new Error(`Maaf, respons gambar diblokir (Alasan: ${candidate.finishReason}).`); } const parts = candidate?.content?.parts || []; const imagePart = parts.find(part => part.inlineData?.mimeType === "image/png"); const textPart = parts.find(part => part.text); const imageUrl = imagePart ? `data:image/png;base64,${imagePart.inlineData.data}` : null; const textResponse = textPart ? textPart.text : null; return { imageUrl, textResponse }; } catch (error) { console.error("Gemini Image Gen Error:", error); throw error; } };
    const displayGeneratedImage = (container, imageUrl) => { container.classList.remove('loading'); container.textContent = ''; const img = document.createElement('img'); img.src = imageUrl; img.alt = "Generated by AI"; img.className = "generated-image"; img.onload = () => img.classList.add('loaded'); const downloadBtn = document.createElement('button'); downloadBtn.className = "download-btn"; downloadBtn.title = "Download Image"; downloadBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`; downloadBtn.addEventListener('click', (e) => { e.stopPropagation(); downloadImage(imageUrl); }); container.appendChild(img); container.appendChild(downloadBtn); };
    const downloadImage = (imageUrl) => { try { if (window.AndroidInterface && typeof window.AndroidInterface.downloadImageFromBase64 === 'function') { const base64Data = imageUrl.split(',')[1]; const fileName = `lunar-ai-image-${Date.now()}.png`; window.AndroidInterface.downloadImageFromBase64(base64Data, fileName); } else { throw new Error("Android interface not available."); } } catch (e) { console.error('Download failed:', e); alert('Gagal mengunduh gambar. Fitur ini hanya tersedia di aplikasi Android.'); } };
    const saveSettings = () => { const newName = userNameSetting.value; currentUser.name = newName; const users = JSON.parse(localStorage.getItem('lunar_users')); users[currentUser.email].name = newName; localStorage.setItem('lunar_users', JSON.stringify(users)); localStorage.setItem('lunar_currentUser', JSON.stringify(currentUser)); userNameDisplay.textContent = newName; currentSystemInstruction = getSystemInstruction(newName.split(' ')[0]); localStorage.setItem('lunar_model', modelSetting.value); currentChatMode = document.querySelector('input[name="chatMode"]:checked').value; localStorage.setItem('lunar_chatMode', currentChatMode); if (themeToggle.checked) { localStorage.setItem('lunar_theme', 'dark'); document.documentElement.classList.add('dark-theme'); } else { localStorage.setItem('lunar_theme', 'light'); document.documentElement.classList.remove('dark-theme'); } settingsModal.classList.remove('visible'); };
    const toggleModelSelectorState = () => { const selectedMode = document.querySelector('input[name="chatMode"]:checked').value; const modelSettingItem = modelSetting.closest('.setting-item'); if (selectedMode === 'image') { modelSetting.disabled = true; modelSettingItem.classList.add('disabled'); attachFileBtn.style.display = 'block'; } else { modelSetting.disabled = false; modelSettingItem.classList.remove('disabled'); attachFileBtn.style.display = 'block'; } };
    const loadSettings = () => { const name = currentUser.name; userNameDisplay.textContent = name; userNameSetting.value = name; const model = localStorage.getItem('lunar_model'); if (model) modelSetting.value = model; const chatMode = localStorage.getItem('lunar_chatMode') || 'standard'; currentChatMode = chatMode; document.querySelector(`input[name="chatMode"][value="${chatMode}"]`).checked = true; const theme = localStorage.getItem('lunar_theme'); if (theme === 'dark') { document.documentElement.classList.add('dark-theme'); themeToggle.checked = true; } else { document.documentElement.classList.remove('dark-theme'); themeToggle.checked = false; } toggleModelSelectorState(); };
    const renderImagePreviews = () => { imagePreviewContainer.innerHTML = ''; stagedImageDataUrls.forEach((dataUrl, index) => { const item = document.createElement('div'); item.className = 'preview-item'; const img = document.createElement('img'); img.src = dataUrl; img.className = 'preview-thumbnail'; const btn = document.createElement('button'); btn.className = 'remove-preview-btn'; btn.innerHTML = '&times;'; btn.onclick = () => removeStagedImage(index); item.appendChild(img); item.appendChild(btn); imagePreviewContainer.appendChild(item); }); if (stagedImageDataUrls.length > 0) { imagePreviewContainer.classList.add('visible'); welcomeScreen.style.display = 'none'; } else { imagePreviewContainer.classList.remove('visible'); } };
    const removeStagedImage = (index) => { stagedImageDataUrls.splice(index, 1); fileInput.value = ''; renderImagePreviews(); };
    const clearImagePreview = () => { stagedImageDataUrls = []; fileInput.value = ''; renderImagePreviews(); };

    sendButton.addEventListener('click', sendMessage); messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } }); document.querySelectorAll('.suggestion-cards .card').forEach(card => { card.addEventListener('click', () => { messageInput.value = card.getAttribute('data-prompt'); sendMessage(); }); }); settingsBtn.addEventListener("click", () => settingsModal.classList.add("visible")); saveSettingsBtn.addEventListener("click", saveSettings); settingsModal.addEventListener("click", e => { if (e.target === settingsModal) settingsModal.classList.remove("visible") }); chatModeRadios.forEach(radio => radio.addEventListener('change', () => { currentChatMode = document.querySelector('input[name="chatMode"]:checked').value; toggleModelSelectorState(); })); attachFileBtn.addEventListener("click", () => fileInput.click()); 
    fileInput.addEventListener("change", (event) => { const files = event.target.files; if (!files) return; const readPromises = Array.from(files).map(file => { if (!file.type.startsWith('image/')) { alert(`File ${file.name} bukan gambar dan akan dilewati.`); return null; } return new Promise((resolve) => { const reader = new FileReader(); reader.onload = (e) => resolve(e.target.result); reader.readAsDataURL(file); }); }).filter(p => p !== null); Promise.all(readPromises).then(newUrls => { stagedImageDataUrls.push(...newUrls); renderImagePreviews(); }); event.target.value = ''; });

    const setupSpeechRecognition = () => { const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; if (!SpeechRecognition) return voiceInputBtn.style.display = "none"; const recognition = new SpeechRecognition(); recognition.interimResults = false; recognition.lang = "id-ID"; recognition.addEventListener("result", e => { messageInput.value = Array.from(e.results).map(r => r[0]).map(t => t.transcript).join(""); sendMessage(); }); recognition.addEventListener("error", e => console.error("Speech recognition error:", e.error)); voiceInputBtn.addEventListener("click", () => { try { recognition.start(); } catch (e) { console.error("Could not start voice recognition:", e); } }); }; menuToggle.addEventListener('click', toggleSidebar); sidebarOverlay.addEventListener('click', closeSidebar); window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isSidebarOpen) closeSidebar(); }); window.addEventListener('resize', () => { if (window.innerWidth > 768 && isSidebarOpen) closeSidebar(); });
    
    // Initialization
    checkLoginStatus();
    setupSpeechRecognition();
});